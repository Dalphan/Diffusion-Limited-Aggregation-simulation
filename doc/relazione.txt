Descrizione:
Diffusion-limited aggregation (DLA) è un processo di formazione di cristalli nel quale le particelle si muovono in uno spazio 2D con moto browniano (cioè in modo casuale) 
e si combinano tra loro quando si toccano. DLA può essere simulato utilizzando una griglia 2D in cui ogni cella può essere occupata da uno o più particelle in movimento. 
Una particella diventa parte di un cristallo (e si ferma) quando si trova in prossimità di un cristallo già formato.

Implementazione:
L'algoritmo utilizzato per simulare il DLA è stato implementato in modo seriale e parallelo, utilizzando le librerie OpenMP e MPI.
I parametri in input della simulazione sono:
- la dimensione della griglia (lunghezza e altezza);
- il numero di iterazioni;
- il numero di particelle;
- coordinate del cristallo iniziale (x and y);
- il numero di thread (solo con OpenMP).
Alla base l'algoritmo è rimasto lo stesso per tutte e tre le implementazione, di seguito i principali punti chiave:
- Allocare dinamicamente la memoria per la griglia (tramite un semplice array a 2 dimensioni causava segmentation fault con input grandi);
- Inizializzare la griglia con valori 255 (EMPTY) e il cristallo iniziale con 1 (CRYSTALIZED). Questo per avere sfondo bianco e cristalli neri nell'immagine finale;
- Inizializzare particelle con coordinate randomiche;
- Inizio simulazione per ogni iterazione:
	- Per ogni particella:
		- Simula movimento browniano tra -1 e 1 in x e y;
		- Controllo se rimane all'interno della griglia;
		- Controllo nei dintorni della particella se esiste un cristallo;
		- Cristallizza particella se vero.
Queste sono le parti del programma che vengono misurate per calcolare il tempo di esecuzione dell'algoritmo, il quale viene stampato in output in microsecondi.
Le particelle sono state implementate tramite una struttura con due interi per salvare le posizioni x e y nella griglia.

Implementazione seriale:
Inizialmente è stata scritta la versione seriale per capire il funzionamento dell'algoritmo e per fornire una base da cui trarre le versioni parallele dell'algoritmo. 
Dopo aver ricevuto in input i parametri necessari, l'algoritmo alloca dinamicamente una griglia bidimensionale di interi di dimensioni height per righe e width per colonne e 
inizializza l'array di particelle con coordinate casuali.
Successivamente per ogni iterazione e per ogni particella, si calcola lo spostamento casuale e si controlla se ha nei dintorni un cristallo. 
Nel caso risulti vero, si cristallizza la particella e la si rimuove dall'array delle particelle (sostituendola con l'ultima particella dell'array e diminuendo il numero 
di particelle totali). In questo modo si velocizza il ciclo man mano che le particelle si cristallizano.
Infine salva l'immagine in formato ppm e libera la memoria allocata dinamicamente.
Ovviamente questa implementazione risulta molto veloce con input di piccole dimensioni, andando a rallentarsi sempre di più con il crescere dell'input.

Implementazione con OpenMP:
Con OpenMP sono state fornite due versioni. Di base l'algoritmo è lo stesso della versione seriale, tranne per le direttive di OpenMP per parallelizzare l'inizializzazione 
delle particelle e la simulazione del moto browniano durante le iterazioni.
Inizialmente nella prima versione, si era scelto di condividere l'array di particelle, assegnando una parte dell'array ad ogni thread, ed usare la direttiva "omp for" 
per parallelizzare il ciclo sulla simulazione del moto browniano. 
Essendo il ciclo sul numero di particelle, questo comporta l'impossibilità di modificarne il numero come nell'algoritmo seriale a causa della limitazione della direttiva "omp for", 
quindi è stato aggiunto un controllo se la particella risulta già cristallizata prima di simulare il moto. 
In seguito si è scelto di non usare la direttiva, ma dividere tramite indici le parti di array su cui itera ogni thread, dato che risultava più veloce della controparte con la 
direttiva "omp for".
Nella seconda versione, l'array di particelle viene diviso per ogni thread, i quali si salvano su un proprio array le particelle su cui poi verrà simulato il moto browniano. 
In questo modo risulta possibile ridurre il numero di particelle man mano che si cristallizzano.
Entrambe le versioni soffrono di una distribuzione ineguale del lavoro, ma questo problema è più evidente nella seconda versione. 
Tuttavia, la seconda versione risulta essere più veloce. Sono state incluse entrambe le versioni per evidenziare la differenza nelle prestazioni dei due algoritmi, 
che differiscono solo leggermente.

Implementazione con MPI:



p = numero di core
Speedup S = Tseriale / Tparallelo
Efficienza E = S / p


